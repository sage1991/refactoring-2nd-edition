# Chapter03 - Bad Smells in Code

리팩터링을 언제 시작하고 언제 그만할지를 판단하는 일은 리팩터링의 작동 원리를 아는 것 못지않게 중요하다.
이 장에서는 리팩터링의 종료 기준보다는 리팩터링하면 해결 할 수 있는 문제의 징후들을 제시하고 있다.

## 3.1 Mysterious Name

코드를 명로하게 표현하는 데 가장 중요한 요소중 하나는 바로 **이름**이다.  
함수, 모듈, 변수, 클래스 등은 그 이름만 보고도 각각이 무슨 일을 하고 어떻게 사용해야 하는지 명확히 알 수 있도록 신경 써서 이름 지어야 한다.

만약 마땅한 이름이 떠오르지 않는다면 설계에 더 근본적인 문제가 숨어 있을 가능성이 높다. 
그래서 혼란스러운 이름을 잘 정리하다 보면 코드가 훨씬 간결해 질 때가 많다.

## 3.2 Duplicated Code

코드가 중복 된다면 각각을 볼 때마다 서로 차이점은 없는지 주의 깊게 살펴 보아야 하고, 
그 중 하나를 변경 할 때는 비슷한 다른 코드도 모두 살펴보고 수정 해야 하는 상황이 생긴다.

따라서 **똑같은 코드 구조가 여러 곳에서 반복 된다면 하나로 통합**하여 더 나은 프로그램을 만들 수 있다.

## 3.3 Long Function

짧은 함수들로 구성된 코드베이스를 얼핏 훑어보면 연산하는 부분이 하나도 없어 보인다. 이 짧은 함수들은 매우 중요한 역할을 한다.
**함수를 짧게 구성함으로써 간접 호출(indirection)효과, 즉 코드를 이해하고, 공유하고, 선택하기 쉬워지기 때문이다.**  

물론 코드를 읽는 사람의 입장 에서는 함수가 하는 일을 파악하기 위해 왔다갔다 해야 하므로 부담이 될 수 있다.
호출부와 선언부를 빠르게 이동하거나 호출과 선언을 동시에 보여주는 개발 환경을 활용 하면 이 부담이 줄어들지만,
**짧은 함수로 구성된 코드를 이해하기 쉽게 만드는 가장 확실한 방법은 좋은 이름이다.**
함수 이름을 잘 지어두면 본문 코드를 볼 이유가 없기 때문이다.

따라서 적극적으로 함수를 쪼개야 하는데, 주석을 달아야 할 만한 부분은 무조건 함수로 만들고 **함수 이름은 동작 방식이 아닌 의도가 드러나게** 짓는다.
즉, 무엇을 하는지를 코드가 잘 설명 해 주지 못할수록 함수로 만드는 것이 유리하다.

## 3.4 Long Parameter List

매개변수 목록이 길어지면 그 자체로 이해하기 어려울 때가 많다.

## 3.5 Global Data

전역 데이터는 코드베이스 어디에서든 건드릴 수 있고 값을 누가 변경 하였는지 찾아낼 메커니즘이 없기 때문에 버그가 발생하기 쉽고 그 원인을 찾아내기 어렵다.

## 3.6 Mutable Data

데이터를 변경 하였을 때 예상치 못한 버그로 이어지는 경우가 종종 있는데, 
코드의 다른 곳에서는 다른 값을 기대 하고 있을 수 있기 때문이다.
따라서 함수형 프로그래밍에서는 **데이터는 절대로 변하지 않고(immutable) 변경 대상의 복사본을 만들어서 반환 한다는 원칙을 기본으로 삼고 있다.**

다만 이러한 방법 외에도 변수를 캡슐화 하여 정해놓은 함수를 거쳐야만 값을 수정 할 수 있도록 하여 수정을 감시하거나 코드를 개선 할 수 있도록 하는 방법도 있다.

## 3.7 Divergent Change

뒤엉킨 번경(divergent change)은 단일 책임 원칙 (Single Responsibility Principle)이 지켜지지 않을 때 나타난다.
**하나의 모듈이 매번 다른 이유들로 인해 여러 가지 방식으로 변경** 된다면 이에 해당한다.

**하나의 모듈은 오직 하나의 이유에 의해서만 변경** 되어야 한다.  

## 3.8 Shotgun Surgery

산탄총 수술(Shotgun Surgery)는 뒤엉킨 변경과 비슷 하면서도 정 반대인데,
코드를 변경 할 때마다 여러 곳에 자잘한 수정을 해야 할 경우 이에 해당한다고 볼 수 있다.
변경이 코드 전반에 퍼져 있다면 찾기도 어렵고 꼭 수정해야 할 중요한 곳을 놓치기 쉽다. 

## 3.9 Feature Envy

기능 편애(Feature Envy)는 어떤 함수가 자기가 속한 모듈의 함수나 데이터 보다 다른 외부 모듈의 함수나 데이터와 상호작용을 할 일이 더 많을때 해당한다.

일반적으로, 프로그램을 모듈화 할 때는 코드를 여러 영역으로 나눈 뒤 영역 안에서 이뤄지는 상호작용은 최대한 늘리고, 영역 사이에서 이뤄지는 상호작용은 최소로 줄이는데 주력한다.
(모듈 내에서는 높은 응집, 모듈 간에는 느슨한 결합)

## 3.10 Data Clumps

## 3.11 Primitive Obsession

## 3.12 Repeated Switches

## 3.13 Loops

## 3.14 Lazy Element

## 3.15 Speculative Generality

## 3.16 Temporary Field

## 3.17 Message Chains

## 3.18 Middle Man

## 3.19 Insider Trading

## 3.20 Large Class

## 3.21 Alternative Classes with Different Interfaces

## 3.22 Data Class

## 3.23 Refused Bequest

## 3.24 Comments
